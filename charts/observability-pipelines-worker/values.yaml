# Default values for Observability Pipelines Worker
# See Observability Pipeline helm documentation to learn more:
## https://docs.datadoghq.com/observability_pipelines/kubernetes/helm/

## FOR AN EFFORTLESS UPGRADE PATH, DO NOT COPY THIS FILE AS YOUR OWN values.yaml.
## ONLY SET THE VALUES YOU WANT TO OVERRIDE IN YOUR values.yaml.

# nameOverride -- Override the name of app
nameOverride: ""

# fullnameOverride -- Override the full qualified app name
fullnameOverride: ""

# rollWorkload -- Add a checksum of the generated ConfigMap to Pod annotations
rollWorkload: true

# commonLabels -- Labels to apply to all resources
commonLabels: {}
#  team_name: dev

datadog:
  # datadog.apiKey -- Your Datadog API key
  apiKey: <DATADOG_API_KEY>
  # datadog.apiKeyExistingSecret -- Use existing Secret which stores API key instead of creating a new one.
  # The value should be set with the `api-key` key inside the secret.
  apiKeyExistingSecret: ""

image:
  # image.name -- Image name to use (relative to `image.repository`)
  name: observability-pipelines-worker
  # image.tag -- Image tag to use
  tag: 0.1.0
  # image.digest -- Image digest to use, takes precedence over `image.tag`
  digest: ""
  ## Currently, we offer images at:
  ## - GCP: use gcr.io/datadoghq
  ## - DockerHub: use docker.io/datadog
  ## - AWS: use public.ecr.aws/datadog
  # image.repository -- Image repository to use
  repository: "gcr.io/datadoghq"
  # image.pullPolicy -- Set the [pullPolicy](https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy)
  pullPolicy: IfNotPresent
  # image.pullSecrets -- Set the [imagePullSecrets](https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod)
  pullSecrets: []
  #  - name: "<REGISTRY_SECRET>"

# replicas -- Specify the number of Pods to create
replicas: 1

# podManagementPolicy -- Specify the [podManagementPolicy](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-management-policies)
# for the StatefulSet
podManagementPolicy: OrderedReady

# Create a Secret resource
secrets:
  # secrets.generic -- Each Key/Value will be added to the Secret's data key, each value should be raw and NOT base64
  # encoded. Any secrets can be provided here. It's commonly used for credentials and other access related values.
  # **NOTE: Don't commit unencrypted secrets to git!**
  generic: {}
    # my_variable: "my-secret-value"
    # datadog_api_key: "api-key"
    # awsAccessKeyId: "access-key"
    # awsSecretAccessKey: "secret-access-key"

autoscaling:
  # autoscaling.enabled -- Create a [HorizontalPodAutoscaler](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)
  enabled: false
  # autoscaling.minReplicas -- Set minimum replicas
  minReplicas: 1
  # autoscaling.maxReplicas -- Set maximum replicas
  maxReplicas: 10
  # autoscaling.targetCPUUtilizationPercentage -- Set target CPU utilization
  targetCPUUtilizationPercentage: 80
  # autoscaling.targetMemoryUtilizationPercentage -- (int) Set target memory utilization
  targetMemoryUtilizationPercentage:
  # autoscaling.customMetric -- Target a custom metric for autoscaling
  customMetric: {}
    #  - type: Pods
    #    pods:
    #      metric:
    #        name: utilization
    #      target:
    #        type: AverageValue
    #        averageValue: 95
  # autoscaling.behavior -- Configure separate scale-up and scale-down behaviors
  behavior: {}
    # scaleDown:
    #   stabilizationWindowSeconds: 300

podDisruptionBudget:
  # podDisruptionBudget.enabled -- Enable a [PodDisruptionBudget](https://kubernetes.io/docs/tasks/run-application/configure-pdb/)
  enabled: false
  # podDisruptionBudget.minAvailable -- The number of Pods that must still be available after an eviction
  minAvailable: 1
  # podDisruptionBudget.maxUnavailable -- (int) The number of Pods that can be unavailable after an eviction
  maxUnavailable:

serviceAccount:
  # serviceAccount.create -- If true, create a ServiceAccount
  create: true
  # serviceAccount.annotations -- Annotations to add to the ServiceAccount
  annotations: {}
  # serviceAccount.name -- The name of the ServiceAccount to use. If not set and `serviceAccount.create` is **true**, a name
  # is generated using the fullname template.
  name:
  # serviceAccount.automountToken -- Automount API credentials for the ServiceAccount
  automountToken: true

# podAnnotations -- Set annotations on Pods.
podAnnotations: {}

# podLabels -- Set labels on Pods.
podLabels:
  vector.dev/exclude: "true"

# podPriorityClassName -- Set the [priorityClassName](https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass)
podPriorityClassName: ""

# podHostNetwork -- Enable hostNetwork on Pods.
podHostNetwork: false

# podSecurityContext -- Allows you to overwrite the default [PodSecurityContext](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
podSecurityContext: {}

# securityContext -- Specify securityContext for containers
securityContext: {}

# command -- Override default image command
command: []

# args -- Override default image arguments
args: []

# env -- Define environment variables
env: []
#  - name: <ENV_VAR_NAME>
#    value: <ENV_VAR_VALUE>
#  - name: <ENV_VAR_NAME>
#    valueFrom:
#      secretKeyRef:
#        name: <SECRET_NAME>
#        key: <KEY_NAME>

# envFrom -- Define environment variables from ConfigMap or Secret data
envFrom: []
#  - configMapRef:
#      name: <CONFIGMAP_NAME>
#  - secretRef:
#     name: <SECRET_NAME>

# containerPorts -- Manually define containerPorts, overriding automated generation of containerPorts
containerPorts: []

# resources -- Set resource requests and limits
resources: {}
  # requests:
  #   cpu: 200m
  #   memory: 256Mi
  # limits:
  #   cpu: 200m
  #   memory: 256Mi

# lifecycle -- Set lifecycle hooks for containers
lifecycle: {}
  # preStop:
  #   exec:
  #     command:
  #     - /bin/sleep
  #     - "10"

# updateStrategy -- Customize the [updateStrategy](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec)
updateStrategy: {}
#   type: RollingUpdate
#   rollingUpdate:
#     maxUnavailable: 1

# terminationGracePeriodSeconds -- Override terminationGracePeriodSeconds
terminationGracePeriodSeconds: 60

# nodeSelector -- Configure [nodeSelector](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
nodeSelector: {}

# tolerations -- Configure [taints and tolerations](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
tolerations: []

# affinity -- Configure [affinity and anti-affinity](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)
affinity: {}

# topologySpreadConstraints -- Configure [topology spread constraints](https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/)
topologySpreadConstraints: []

service:
  # service.enabled -- If **true**, create and provide a Service resource
  enabled: true
  # service.type -- Set the type for the Service
  type: "ClusterIP"
  # service.annotations -- Set annotations on the Service
  annotations: {}
  # service.topologyKeys -- Specify the [topologyKeys](https://kubernetes.io/docs/concepts/services-networking/service-topology/#using-service-topology)
  topologyKeys: []
  #   - "kubernetes.io/hostname"
  #   - "topology.kubernetes.io/zone"
  #   - "topology.kubernetes.io/region"
  #   - "*"
  # service.ports -- Manually set the Service ports, overriding automated generation of Service ports
  ports: []
  # service.externalTrafficPolicy -- Specify the [externalTrafficPolicy](https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip)
  externalTrafficPolicy: ""
  # service.loadBalancerIP -- Specify the [loadBalancerIP](https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer)
  loadBalancerIP: ""
  # service.ipFamilyPolicy -- Configure [IPv4/IPv6 dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/)
  ipFamilyPolicy: ""
  # service.ipFamilies -- Configure [IPv4/IPv6 dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/)
  ipFamilies: []

serviceHeadless:
  # serviceHeadless.enabled -- If **true**, create and provide a Headless Service resource
  enabled: true

ingress:
  # ingress.enabled -- If **true**, create and use an Ingress resource
  enabled: false
  # ingress.className -- Specify the [ingressClassName](https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress),
  # requires Kubernetes >= 1.18
  className: ""
  # ingress.annotations -- Set annotations on the Ingress
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # ingress.hosts -- Configure the hosts and paths for the Ingress
  hosts: []
  #  - host: chart-example.local
  #    paths:
  #      - path: /
  #        pathType: ImplementationSpecific
  #        # Specify the port name or number on the Service
  #        # Using name requires Kubernetes >=1.19
  #        port:
  #          name: ""
  #          number: ""
  # ingress.tls -- Configure TLS for the Ingress
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# existingConfigMaps -- List of existing ConfigMaps for Vector's configuration instead of creating a new one. Requires
# dataDir to be set. Additionally, containerPorts, service.ports, and serviceHeadless.ports should be specified based on
# your supplied configuration. If set, this parameter takes precedence over customConfig and the chart's default configs.
existingConfigMaps: []

# dataDir -- Specify the path for Vector's data, only used when existingConfigMaps are used
dataDir: ""

# customConfig -- Override Vector's default configs, if used **all** options need to be specified. This section supports
# using helm templates to populate dynamic values. See Vector's [configuration documentation](https://vector.dev/docs/reference/configuration/)
# for all options.
customConfig: {}
  # data_dir: /vector-data-dir
  # api:
  #   enabled: true
  #   address: 127.0.0.1:8686
  #   playground: false
  # sources:
  #   vector:
  #     address: 0.0.0.0:6000
  #     type: vector
  #     version: "2"
  # sinks:
  #   stdout:
  #     type: console
  #     inputs: [vector]
  #     encoding:
  #       codec: json

# extraVolumes -- Additional Volumes to use
extraVolumes: []

# extraVolumeMounts -- Additional Volume to mount
extraVolumeMounts: []

# initContainers -- Init Containers to be added
initContainers: []

# extraContainers -- Extra Containers to be added
extraContainers: []

persistence:
  # persistence.enabled -- If **true**, create and use PersistentVolumeClaims
  enabled: false
  # persistence.existingClaim -- Name of an existing PersistentVolumeClaim to use
  existingClaim: ""
  # persistence.storageClassName -- Specifies the storageClassName for PersistentVolumeClaims
  # storageClassName: default

  # persistence.accessModes -- Specifies the accessModes for PersistentVolumeClaims
  accessModes:
    - ReadWriteOnce
  # persistence.size -- Specifies the size of PersistentVolumeClaims
  size: 10Gi
  # persistence.finalizers -- Specifies the finalizers of PersistentVolumeClaims
  finalizers:
    - kubernetes.io/pvc-protection
  # persistence.selectors -- Specifies the selectors for PersistentVolumeClaims
  selectors: {}

# dnsPolicy -- Specify the [dnsPolicy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy)
dnsPolicy: ClusterFirst

# dnsConfig -- Specify the [dnsConfig](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config)
dnsConfig: {}
  # nameservers:
  #   - 1.2.3.4
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

# livenessProbe -- Override default liveness probe settings. If customConfig is used, requires customConfig.api.enabled
# to be set to true.
livenessProbe: {}
  # httpGet:
  #   path: /health
  #   port: api

# readinessProbe -- Override default readiness probe settings. If customConfig is used,
# requires customConfig.api.enabled to be set to true.
readinessProbe: {}
  # httpGet:
  #   path: /health
  #   port: api
