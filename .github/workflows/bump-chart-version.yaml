name: Bump Chart Version

on:
  pull_request:
    types: [labeled, unlabeled, opened, edited, synchronize]

# Permission forced by repo-level setting; only elevate on job-level
permissions:
  pull-requests: write
  contents: write
  # packages: read

jobs:
  bump-chart-version:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Extract all chart label information and update Chart.yaml and CHANGELOG.md
        id: update_charts
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull request found in context payload.");
              return;
            }

            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            const labelNames = labels.map(l => l.name);

            // Gather all file changes and individual commit messages.
            const fileChanges = [];
            const commitMessages = [];
        
            // Helper to parse a semver string (e.g., "1.2.3") into an object {major, minor, patch}
            function parseVersion(versionStr) {
            const parts = versionStr.split('.');
              return {
                major: parseInt(parts[0], 10),
                minor: parseInt(parts[1], 10),
                patch: parseInt(parts[2], 10)
              };
            }
            // Helper to produce a semver string
            function makeVersion({ major, minor, patch }) {
              return `${major}.${minor}.${patch}`;
            }

            // Get the list of charts that need a version bump (or changelog update)
            const chartsToBump = [];
            for (const label of labelNames) {
              const match = label.match(/^(?<chartName>[^/]+)\/(?<versionType>minor-version|patch-version|no-version-bump)$/);
              if (match) {
                chartsToBump.push({
                  chartName: match.groups.chartName,
                  bumpType: match.groups.versionType
                });
              }
            }
            
            // Sync with base branch
            // Check if there is drift; if there is drift, sync base branch before updating version
            // If it's a fork PR, the branch will need to be synced manually since it requires a PAT
          
            const main = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: "main",
            });
            
            const mainSHA = main.data.commit.sha;

            // Compare the base and head branches to find their merge base
            const comparison = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: pr.base.ref,
              head: pr.head.ref
            });

            // Use the merge_base_commit SHA
            const mergeBaseSHA = comparison.data.merge_base_commit.sha;
            
            for (const info of chartsToBump) {
              const { chartName, bumpType } = info;
              core.info(`Examining '${chartName}' for a ${bumpType} update…`);

              // Get the base Chart.yaml (from the PR base branch)
              let baseChartFile;
              try {
                baseChartFile = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/Chart.yaml`,
                  ref: mergeBaseSHA
                });
              } catch (error) {
                core.setFailed(`Could not get base Chart.yaml for ${chartName}: ${error.message}`);
                return;
              }
              const baseContent = Buffer.from(baseChartFile.data.content, baseChartFile.data.encoding).toString();
              const baseVersionMatch = baseContent.match(/^version:\s+(\S+)/m);
              if (!baseVersionMatch) {
                core.setFailed(`No 'version:' found in base branch Chart.yaml for ${chartName}. Skipping…`);
                return;
              }
              const baseVersion = baseVersionMatch[1].trim();
              core.info(`Base version for '${chartName}' is '${baseVersion}'.`);

              // Read the PR Chart.yaml on the PR head branch.
              let prChartFile;
              try {
                prChartFile = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/Chart.yaml`,
                  ref: pr.head.ref
                });
              } catch (error) {
                core.setFailed(`Could not get PR Chart.yaml for ${chartName}: ${error.message}`);
                return;
              }
              const prContent = Buffer.from(prChartFile.data.content, prChartFile.data.encoding).toString();
              const prVersionMatch = prContent.match(/^version:\s+(\S+)/m);
              if (!prVersionMatch) {
                core.setFailed(`No 'version:' found in PR Chart.yaml for ${chartName}. Skipping…`);
                return;
              }
              const prVersion = prVersionMatch[1].trim();
              core.info(`PR version for '${chartName}' is '${prVersion}'.`);

              // Calculate the desired version based on bump type.
              const baseParsed = parseVersion(baseVersion);
              let desiredParsed = {...baseParsed};
              if (bumpType === 'patch-version') {
                desiredParsed.patch += 1;
              } else if (bumpType === 'minor-version') {
                desiredParsed.minor += 1;
                desiredParsed.patch = 0;
              }
              const desiredVersion = makeVersion(desiredParsed);
              core.info(`Desired version for '${chartName}' is '${desiredVersion}'.`);

              // If the Chart.yaml version is not what we expect, update it.
              if (prVersion !== desiredVersion) {
                core.info(`For '${chartName}', base was '${baseVersion}' but PR had '${prVersion}'. Changing version to '${desiredVersion}'.`);
                const newChartContent = prContent.replace(
                  /^version:\s+\S+/m,
                  `version: ${desiredVersion}`
                );
                fileChanges.push({
                  path: `charts/${chartName}/Chart.yaml`,
                  content: newChartContent
                });
                commitMessages.push(`bump version for ${chartName} to ${desiredVersion} (${bumpType})`);
              } else {
                core.info(`'${chartName}' version is already correct ('${prVersion}').`);
              }

              // Unless the bump type is no-version-bump, prepare CHANGELOG update.
              if (bumpType === 'no-version-bump') {
                core.info(`Skipping CHANGELOG update for '${chartName}' (no-version-bump).`);
                continue;
              }

              // Get base and head CHANGELOG.md files.
              let baseChangelog, prChangelog;
              try {
                baseChangelog = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/CHANGELOG.md`,
                  ref: mergeBaseSHA
                });
              } catch (error) {
                core.setFailed(`Could not get base CHANGELOG.md for ${chartName}: ${error.message}`);
                return;
              }
              try {
                prChangelog = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/CHANGELOG.md`,
                  ref: pr.head.ref
                });
              } catch (error) {
                core.setFailed(`Could not get head CHANGELOG.md for ${chartName}: ${error.message}`);
                return;
              }
              if (prChangelog.data.sha == baseChangelog.data.sha) {
                const changelogContent = Buffer.from(prChangelog.data.content, prChangelog.data.encoding).toString();
                const newDate = new Date().toISOString().split('T')[0];
                const prLink = `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${pr.number}`;
                const newEntry = `## ${desiredVersion} \n\n* ${pr.title} ([#${pr.number}](${prLink})).\n\n`;
  
                let newChangelogContent;
                const lines = changelogContent.split('\n');
                const versionHeaderIdx = lines.findIndex(line => line.trim().startsWith('##'));
                if (versionHeaderIdx !== -1) {
                  const headerSection = lines.slice(0, versionHeaderIdx).join('\n').trimEnd();
                  const remaining = lines.slice(versionHeaderIdx).join('\n');
                  newChangelogContent = `${headerSection}\n\n${newEntry}${remaining}`;
                } else {
                  newChangelogContent = newEntry + changelogContent;
                }
                fileChanges.push({
                  path: `charts/${chartName}/CHANGELOG.md`,
                  content: newChangelogContent
                });
                commitMessages.push(`update changelog for ${chartName} with version ${desiredVersion}`);
                core.info(`CHANGELOG.md for '${chartName}' updated with a new entry for version ${desiredVersion}.`);
              } else {
                core.info(`CHANGELOG.md for '${chartName}' has already been modified in this branch. Skipping changelog update.`);
              }

              // Get head README.md file
              let prReadme;
              try {
                prReadme = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/README.md`,
                  ref: pr.head.ref
                });
              } catch (error) {
                core.setFailed(`Could not get head README.md for ${chartName}: ${error.message}`);
                return;
              }
              
              // Update local README.md
              try {
                await exec.exec('/bin/bash', ['.github/helm-docs.sh']);
              } catch (error) {
                core.setFailed(`Could not update README.md for ${chartName}: ${error.message}`);
                return;
              }
              const fs = require('fs');
              const localReadmeContent = fs.readFileSync(`charts/${chartName}/README.md`, { encoding: 'utf-8' });
              const prReadmeContent = Buffer.from(prReadme.data.content, 'base64').toString('utf-8');

              // Check for diff between head and local README.md 
              if (prReadmeContent !== localReadmeContent) {
                fileChanges.push({
                  path: `charts/${chartName}/README.md`,
                  content: localReadmeContent
                });
                commitMessages.push(`update readme for ${chartName} with version ${desiredVersion}`);
                core.info(`README.md for '${chartName}' updated with a new entry for version ${desiredVersion}.`);
              } else {
                core.info(`README.md already up-to-date for '${chartName}' chart. Skipping README update.`)
              }
            }
            
            core.info("Done checking all labeled charts.");

            // If no file changes were collected, nothing to commit.
            if (fileChanges.length === 0) {
              core.info("No file changes to commit.");
              return;
            }

            // Get the current commit of the PR head branch.
            const { data: branchData } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: pr.head.ref
            });
            const baseCommitSha = branchData.commit.sha;
            const baseTreeSha = branchData.commit.commit.tree.sha;
            core.info(`Base commit for branch '${pr.head.ref}' is ${baseCommitSha}`);

            // Prepare tree entries from each file change.
            // (Mode "100644" means a normal non‐executable file.)
            const treeItems = fileChanges.map(change => ({
              path: change.path,
              mode: "100644",
              type: "blob",
              content: change.content
            }));

            // Create a new tree with these modifications.
            const newTreeResponse = await github.rest.git.createTree({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tree: treeItems,
              base_tree: baseTreeSha
            });
            const newTreeSha = newTreeResponse.data.sha;
            core.info(`Created new tree ${newTreeSha}`);

            // Create a combined commit message.
            const commitMessage = `chore: update charts and changelogs\n\n` +
                                  commitMessages.map(msg => `- ${msg}`).join('\n');

            // Create a new commit object.
            const newCommitResponse = await github.rest.git.createCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              message: commitMessage,
              tree: newTreeSha,
              parents: [baseCommitSha]
            });
            const newCommitSha = newCommitResponse.data.sha;
            core.info(`Created new commit ${newCommitSha}`);

            // Update the head branch reference to point to the new commit.
            await github.rest.git.updateRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${pr.head.ref}`,
              sha: newCommitSha
            });
            core.info(`Branch '${pr.head.ref}' has been updated with a combined commit.`);
