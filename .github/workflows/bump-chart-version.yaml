name: Bump Chart Version

on:
  pull_request:
    types: [labeled, unlabeled, opened, edited, synchronize]

# Permission forced by repo-level setting; only elevate on job-level
permissions:
  pull-requests: write
  contents: write
  # packages: read

jobs:
  bump-chart-version:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Extract all chart label information and update Chart.yaml and CHANGELOG.md
        id: update_charts
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull request found in context payload.");
              return;
            }

            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            const labelNames = labels.map(l => l.name);

            const fileChanges = [];
            const commitMessages = [];

            function parseVersion(versionStr) {
              const parts = versionStr.split('.');
              return {
                major: parseInt(parts[0], 10),
                minor: parseInt(parts[1], 10),
                patch: parseInt(parts[2], 10)
              };
            }

            function makeVersion({ major, minor, patch }) {
              return `${major}.${minor}.${patch}`;
            }

            const chartsToBump = [];
            for (const label of labelNames) {
              const match = label.match(/^(?<chartName>[^/]+)\/(?<versionType>minor-version|patch-version|no-version-bump)$/);
              if (match) {
                chartsToBump.push({
                  chartName: match.groups.chartName,
                  bumpType: match.groups.versionType
                });
              }
            }

            const comparison = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: pr.base.ref,
              head: pr.head.ref
            });
            const mergeBaseSHA = comparison.data.merge_base_commit.sha;

            for (const info of chartsToBump) {
              const { chartName, bumpType } = info;
              core.info(`Examining '${chartName}' for a ${bumpType} update…`);

              let baseChartFile;
              try {
                baseChartFile = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/Chart.yaml`,
                  ref: mergeBaseSHA
                });
              } catch (error) {
                core.setFailed(`Could not get base Chart.yaml for ${chartName}: ${error.message}`);
                return;
              }
              const baseContent = Buffer.from(baseChartFile.data.content, baseChartFile.data.encoding).toString();
              const baseVersionMatch = baseContent.match(/^version:\s+(\S+)/m);
              if (!baseVersionMatch) {
                core.setFailed(`No 'version:' found in base branch Chart.yaml for ${chartName}. Skipping…`);
                return;
              }
              const baseVersion = baseVersionMatch[1].trim();
              core.info(`Base version for '${chartName}' is '${baseVersion}'.`);

              let prChartFile;
              try {
                prChartFile = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/Chart.yaml`,
                  ref: pr.head.ref
                });
              } catch (error) {
                core.setFailed(`Could not get PR Chart.yaml for ${chartName}: ${error.message}`);
                return;
              }
              const prContent = Buffer.from(prChartFile.data.content, prChartFile.data.encoding).toString();
              const prVersionMatch = prContent.match(/^version:\s+(\S+)/m);
              if (!prVersionMatch) {
                core.setFailed(`No 'version:' found in PR Chart.yaml for ${chartName}. Skipping…`);
                return;
              }
              const prVersion = prVersionMatch[1].trim();
              core.info(`PR version for '${chartName}' is '${prVersion}'.`);

              const baseParsed = parseVersion(baseVersion);
              let desiredParsed = { ...baseParsed };
              if (bumpType === 'patch-version') {
                desiredParsed.patch += 1;
              } else if (bumpType === 'minor-version') {
                desiredParsed.minor += 1;
                desiredParsed.patch = 0;
              }
              const desiredVersion = makeVersion(desiredParsed);
              core.info(`Desired version for '${chartName}' is '${desiredVersion}'.`);

              if (prVersion !== desiredVersion) {
                core.info(`For '${chartName}', base was '${baseVersion}' but PR had '${prVersion}'. Changing version to '${desiredVersion}'.`);
                const newChartContent = prContent.replace(/^version:\s+\S+/m, `version: ${desiredVersion}`);
                fs.writeFileSync(`charts/${chartName}/Chart.yaml`, newChartContent, 'utf8');

                fileChanges.push({ path: `charts/${chartName}/Chart.yaml`, content: newChartContent });
                commitMessages.push(`bump version for ${chartName} to ${desiredVersion} (${bumpType})`);
              } else {
                core.info(`'${chartName}' version is already correct ('${prVersion}').`);
              }

              if (bumpType === 'no-version-bump') {
                core.info(`Skipping CHANGELOG update for '${chartName}' (no-version-bump).`);
                continue;
              }

              let baseChangelog, prChangelog;
              try {
                baseChangelog = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/CHANGELOG.md`,
                  ref: mergeBaseSHA
                });
              } catch (error) {
                core.setFailed(`Could not get base CHANGELOG.md for ${chartName}: ${error.message}`);
                return;
              }
              try {
                prChangelog = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chartName}/CHANGELOG.md`,
                  ref: pr.head.ref
                });
              } catch (error) {
                core.setFailed(`Could not get head CHANGELOG.md for ${chartName}: ${error.message}`);
                return;
              }

              if (prChangelog.data.sha !== baseChangelog.data.sha) {
                core.info(`CHANGELOG.md for '${chartName}' has already been modified. Skipping changelog update.`);
                continue;
              }

              const changelogContent = Buffer.from(prChangelog.data.content, prChangelog.data.encoding).toString();
              const newDate = new Date().toISOString().split('T')[0];
              const prLink = `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${pr.number}`;
              const newEntry = `## ${desiredVersion} \n\n* ${pr.title} ([#${pr.number}](${prLink})).\n\n`;

              let newChangelogContent;
              const lines = changelogContent.split('\n');
              const versionHeaderIdx = lines.findIndex(line => line.trim().startsWith('##'));
              if (versionHeaderIdx !== -1) {
                const headerSection = lines.slice(0, versionHeaderIdx).join('\n').trimEnd();
                const remaining = lines.slice(versionHeaderIdx).join('\n');
                newChangelogContent = `${headerSection}\n\n${newEntry}${remaining}`;
              } else {
                newChangelogContent = newEntry + changelogContent;
              }

              fs.writeFileSync(`charts/${chartName}/CHANGELOG.md`, newChangelogContent, 'utf8');
              fileChanges.push({ path: `charts/${chartName}/CHANGELOG.md`, content: newChangelogContent });
              commitMessages.push(`update changelog for ${chartName} with version ${desiredVersion}`);
            }

            core.info("Done checking all labeled charts.");

            try {
              await exec.exec('/bin/bash', ['.github/helm-docs.sh']);
            } catch (exitCode) {
              // Intentionally ignore non-zero exit
            }

            for (const chart of chartsToBump) {
              let baseReadme, prReadme;
              try {
                baseReadme = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chart.chartName}/README.md`,
                  ref: mergeBaseSHA
                });
              } catch (error) {
                core.setFailed(`Could not get base README.md for ${chart.chartName}: ${error.message}`);
                return;
              }
              try {
                prReadme = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: `charts/${chart.chartName}/README.md`,
                  ref: pr.head.ref
                });
              } catch (error) {
                core.setFailed(`Could not get head README.md for ${chart.chartName}: ${error.message}`);
                return;
              }

              if (prReadme.data.sha !== baseReadme.data.sha) {
                core.info(`README.md for '${chart.chartName}' has already been modified. Skipping.`);
                continue;
              }

              const readmeContent = fs.readFileSync(`charts/${chart.chartName}/README.md`, 'utf-8');
              if (readmeContent !== Buffer.from(prReadme.data.content, prReadme.data.encoding).toString()) {
                fileChanges.push({ path: `charts/${chart.chartName}/README.md`, content: readmeContent });
                commitMessages.push(`update readme for ${chart.chartName}`);
              }
            }

            if (fileChanges.length === 0) {
              core.info("No file changes to commit.");
              return;
            }

            const { data: branchData } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: pr.head.ref
            });
            const baseCommitSha = branchData.commit.sha;
            const baseTreeSha = branchData.commit.commit.tree.sha;

            const treeItems = fileChanges.map(change => ({
              path: change.path,
              mode: "100644",
              type: "blob",
              content: change.content
            }));

            const newTreeResponse = await github.rest.git.createTree({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tree: treeItems,
              base_tree: baseTreeSha
            });

            const newCommitResponse = await github.rest.git.createCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              message: `chore: update charts\n\n${commitMessages.map(msg => `- ${msg}`).join('\n')}`,
              tree: newTreeResponse.data.sha,
              parents: [baseCommitSha]
            });

            await github.rest.git.updateRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${pr.head.ref}`,
              sha: newCommitResponse.data.sha
            });

            core.info(`Branch '${pr.head.ref}' has been updated with a combined commit.`);